3/16(월)

*10-1 static 변수(클래스 변수)
static 변수는 인스턴스의 생성과 상관없이 초기화되는 변수
static 변수의 접근 방법은 어떠한 형태로 접근을 하건, 접근의 내용에는 차이가 없다.
(다만 접근 하는 위치에 따라서 접근의 형태가 달라질 수 있다.)-인스턴스의 이름을 이용한 접근방법, 클래스의 이름을 이용한 접근방법
JVM은 실행과정에서 필요한 클래스의 정보를 메모리에 로딩한다. 바로 이 Loading 시점에서 static 변수가 초기화 된다.
동일한 클래스의 인스턴스 사이에서의 데이터 공유가 필요할때 static 변수는 유용하게 활용된다.

*10-2 static 메소드(클래스 메소드)
인스턴스를 생성하지 않아도 static 메소드는 호출이 가능하다.
static메소드는 인스턴스에 속하지 않기 때문에 인스턴스 멤버에 접근이 불가능하다.

*10-3 System.out.println & public static void main
system(클래스이름).out(static변수).println(메소드)
public static void main --> main은 프로그램의 시작과 끝을 정의해준다. 클래스에 종속되지않고 하나의 main만 실행되어야하기 때문에 static으로 정의해준다.
보통 main메소드를 따로 정의해두는것이 좋다.
모든 메소드는 자신이 속한 클래스의 인스턴스 생성이 가능하다.

*11-1 메소드 오버로딩(Overloading)
같은 클래스 안에 메소드의 이름이 동일하면 안된다. (이유는 구분이 되지않기 때문에)
그러나 매개변수의 개수와 자료형이 다르면 이름이 같은 메소드를 여러개 생성가능하다.(=메소드 오버로딩)
생성자의 재호출을 위한 키워드 this (인스턴스에서 정의한 변수를 의미한다.)

*11-2 String 클래스
String 클래스는 자바를 완성시키는 클래스이다. 
(문자열을 담는 하나의 인스턴스를 만든다.)
String 안의 문자열 정보는 바꿀 수 없다.(이유는 프로그래밍이 느려지는 현상을 방지하기 위해)
동일한 문자열을 생성할 경우에는 기존에 있던 문자열을 참조한다.(그러기위해 문자열의 정보를 바꿀 수 없게 정의해두었다.)

*11-3 API Document의 참조를 통한 String 클래스의
API 문서를 볼줄 알아야하고, 참조할 줄도 알아야한다.
문자열의 길이반환( length() ), 두 문자열의 결합( concat(String str) ), 두 문자열의 비교( compareTo(String anotherString) )
문자열 복사( String(String original) ) --> 비교연산자는 참조값을 비교한다.

*11-4 StringBuilder & StringBuffer 클래스
StringBuilder는 문자열의 저장 및 변경을 위한 메모리 공간을 지니는 클래스
둘은 메소드의수(생성자 포함), 메소드의 기능, 메소드의이름과 매개변수형이 같지만 
StringBuffer는 쓰레드에 안전 StringBuilder는 쓰레드에 불안전 차이이다.

*12-1 콘솔 출력(Console Output)
모니터를 통한 데이터 출력
이스케이프 시퀀스(Escape Sequence)=문자열 안에서 특별한 의미로 해석되는 문자 ex) \n, \t, \",\\

*12-2 콘솔 입력(Console Input)
키보드를 통한 데이터 입력
//과거의 정수 입력 방식
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
String str=br.readLine();
int num=Integer.pareseInt(str);
//개선된 정수 입력 방식(Scanner 클래스)
Scanner kb=new Scanner(System.in);
int num=kb.nextInt();

*13-1 배열이라는 존재가 필요한 이유
많은 수의 변수라 할지라도 하나의 문장으로 선언하는 것이 가능.
배열은 순차접근이 가능.

*13-2 1차원 배열의 이해와 활용
배열도 인스턴스이다. 둘 이상의 데이터를 저장할 수 있는 형태의 인스턴스이다.
배열안에 저장되는 값은 인스턴스의 참조값이다.
배열의 선언과 동시에 초기화하는 방법은 4가지가 있다.
배열도 인스턴스이기 때문에 메소드 호출시의 인자전달 및 반환의 과정이 일반적인 인스턴스들과 다르지 않다.

*13-3 다차원 배열의 이해와 활용
2차원배열 ex) int[ ][ ] ref=new int[ ][ ]
int[세로][가로]를 의미한다.

*13-4 for-each
for문과는 차이가 있다.
배열의 일부가 아닌, 배열의 전체를 참조할 필요가 있는 경우에 유용하게 사용할 수 있다.
ex) for( int e : arr){ System.out.print(e+" "); } 
for-each 문을 통한 값의 변경은 실제 배열에 반영되지 않으니, 값의 참조를 목적으로만 사용해야한다.
배열요소 각각을 e라고 할때, arr의 배열들을 모두 출력해라.
인스턴스 배열에 저장된 참조 값의 변경은 불가능하지만, 참조 값을 통한 인스턴스의 접근은 가능하다.

*13-5 main 메소드로의 데이터 전달
String[] args == 스트링 인스턴스의 참조값을 저장하는 배열

*14-1 상속은 재활용 + 알파(@)
객체지향=>class, 상속(=재활용이 아니다.)
상속을 통해 연관된 일련의 클래스에 대한 공통적인 규약을 정의하고 적용하는데, 상속의 실질적인 목적이 있다.
CBD의 컴포넌트는 크기가 거대한 클래스들의 집합체이다.
재활용을 고려할시 설계에 필요한 시간,인력,돈이 몇 배는 길어진다.

*14-2 상속의 기본문법 이해
상속은 기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것.
super( 변수명 ); 으로 부모클래스의 변수를 초기화 시켜줘야한다.
하위클래스는 모든 멤버(=변수)의 초기화할 의무가 있다.
하위클래스는 상위클래스의 맴버도 초기화할 의무가 있다. (상위클라스의 생성자를 통해서 초기화할 수 있다.=super)
하위클래스의 인스턴스를 초기화하기전에 상위클래스의 인스턴스를 먼저 초기화해야한다.(=초기화할때 super를 맨앞에 두어야함)

*14-3 상속과 접근제어 지시자
private 멤버도 상속은 된다. 다만 접근만 불가능하다.

*14-4 static 변수(메소드)의 상속과 생성자의 상속에 대한 논의
상위 클래스의 static 변수에 하위 클래스도 그냥 이름만으로 접근 가능하다.
이유는, static변수는 프로그래밍 시작하면 딱한번 메모리 공간에 올라가서 모든 영역에서 공유하기 때문이다.





