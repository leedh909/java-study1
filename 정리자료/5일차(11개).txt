3/21(토)

*15-1 상속을 위한 관계
상속은 강한 연결고리를 형성한다.
상속과계에 있는 두 클래스 사이에는 IS-A관계의 성립해야 한다.
HAS-A 관계에 상속을 적용한 경우 (소유관계를 나타낸다) ex) 경찰 has a 총!

*15-2 하위 클래스에서 메소드를 다시 정의한다면?
메소드 오버라이딩
-상위 클래스에 정의된 메소드의 이름, 반환형, 매개변수 선언까지 완전히 동일한 메소드를 하위 클래스에서 다시 정의하는 것
Speaker bs=new BaseEnSpeaker();
참조변수 bs가 부모의 메소드는 불러올 수 있으나 자식의 메소드를 불러오면 컴파일 에러가 나온다.
참조변수에 대한 자료형 변수는 유지하지만 실행이 끝나면 뭘 참조하는지에 대해서는 삭제된다.
동일한 이름의 메소드(오버로딩)
후에 나온 메소드가 앞에 메소드를 가리는 효과(오버라이딩)
메소드가 가려지면 마지막에 제시한 메소드의 값이 나온다.
인스턴스 변수는 오버라이딩 관계에 놓이지 않는다.
접근하는 변수의 종류는 참조변수의 자료형에 따라서 달라진다. 

*15-3 참조변수의 인스턴스 참조와 instanceof 연산자
형변환 가능유무
ex)(불가능) Box b= new Box();  --> PB b2= (PB)b; 하면 허용하지 않는다. 이유는 상위클래스의 변수를 지정하기 때문이다.
ex)(가능) Box b= new GPB(); --> GPB b2= (GPB)b; 하면 허용한다. 이유는 참조하는 변수가 같은 것이기 때문이다.
if(box instanceof GoldPaperBox) 이면 box가 형변환할수 있다면 true 아니면 false.
==> 가능할경우는 box보다 하위 클래스의 변수이면 가능 아니면 불가능

*16-1 개인정보 관리 프로그램(MyFriednInfoBook.java)
Data + 처리(흐름) 을 따로 이해하면 아마추어 정도는 할 수 있다.
흐름= 저장하고, 저장한 데이터를 참조하는 방법을 의미한다.
instanceof가 상속을 대신해서 들어가는 코드는 좋은 코드가 아니다.
상속을 통해 연관된 일련의 클래스에 대한 공통적인 규약을 정의할 수 있습니다.

*16-2 모든 클래스가 상속하는 Object 클래스
java의 모든 클래스는 Object클래스를 상속한다.(직접이나 간접적으로 Object클래스를 상속할 것이다.)
->(이유는 상속은 공통된 규약을 적용한다. Object 클래스의 어떤 규약을 담아놓고 자바에서 적용하기위해서.)

*16-3 final 클래스와 final 메소드
클래스를 final로 정의하면 다른 클래스가 상속하는 것을 허용하지 않는다는 의미이다. 
메소드도 final로 선언하면 오버라이딩을 허용하지 않는다는 의미이다.

*17-1 abstract 클래스
추상화-[덜 완성된 클래스]
하나 이상의 메소드가 abstract면, 클래스도 abstract이다.

*17-2 Interface1
Interface는 상속이라 안하고 구현한다라고 말한다.
Interface는 다른 회사에게 외주를 줄때 여러개의 클래스들을 하나의 클래스로 가져와 내가 작업하고 있는 클래스들과 연결하는 클래스이다.
한그룹(=클래스들)과 다른 그룹(=클래스들)을 잇는 클래스 = Interface 라고 한다.(연결고리 역할을 한다)
java는 다중상속이 안된다. Interface는 다중상속의 효과를 낼 수 있다.
Interface로 선언하면 인터페이스 내에 선언된 메소드는 무조건 public abstract로 선언된다.
인터페이스 내에 선언된 변수는 무조건 public static final로 선언된다.
둘 이상의 인터페이스를 동시에 구현 가능
인터페이스의 상속은 extends가 아닌 implements를 사용한다.
인터페이스에서 인터페이스를 상속할때에는 implements가 아닌 extends를 사용한다.

*17-2 Interface2
무엇인가를 표시하는(클래스의 특성을 표시하는) 용도로도 인터페이스는 사용된다.
TV tv=iptv; Computer comp=iptv; 이 두개의 참조값은 효과만보면 다중상속을 나타낸다.
하지만 자바에서는 다중상속을 지원 안하기 때문에 둘 중 하나는 implements이고 하나는 extends 이다.
(= class IPTV extends TV implements Computer )

*17-3 Inner 클래스
Inner 클래스(클래스 내부에 다시 정의된 클래스, 바깥쪽에 선언된 OuterClass에 의존적이다.)와 
(static Inner 클래스)=Nested 클래스
Inner클래스의 인스턴스는 Outer클래스의 인스턴스에 종속적이다.
Outer클래스의 인스턴스 생성 후에야 Inner클래스의 인스턴스 생성이 가능하다.
ex) OuterClass.InnerClass inn1= out1.new InnerClass(); 라고 선언하면 out1에 종속적인 inn1이 생성된다.

*17-4 Local 클래스와 Anonymous 클래스
Anonymous클래스, Local클래스는 Inner클래스의 성향을 뛰고 있다.
Local클래스는 메소드 내에 정의가 되어서, 메소드 내에서만 인스턴스의 생성 및 참조 변수의 선언이 가능하다는 특징이 있다.
Local의미는 메소드 내에 클래스를 정의한다라는 의미(=지역)
메소드가 반환하는 순간 매개변수와 지역변수는 소멸하는데 단,final로 선언이 변수의 접근은 허용한다.(->어떤 메모리 공간에 복사해 두겠다.)
Anonymous클래스와 Local클래스의 차이는 클래스의 이름이 정의되어 있지 않다는 사실에서만 차이가 있다.
Anonymous클래스는 이름이 없는 클래스를 의미한다.
