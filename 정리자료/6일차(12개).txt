3/23(월)

*18-1 예외처리에 대한 이해와 try~catch문의 기본
프로그램에서 에러라는건 대부분 컴파일에러이다.
논리적 오류를 예외처리해야한다.
프로그래머의 주관적인 판단으로 예외처리한다.
try{ 정상적인 흐름=예외상황이 발생하면 catch구문으로 넘긴다. }catch{ 예외 처리하기 위한 목적 }
가상머신에 의해 생성된 인스턴스의 참조 값 전달=>(ArithmenticException e)=예외클래스
일의 단위(상수가 포함된 부분부터 호출하는 부분까지)가 구성! 함께 실행되거나, 모두 실행되지 않거나!
(오류발생시 실행하면 안 되는 부분을 효율적으로 건너 뛸 수 있다.)
모든 예외 클래스는 Throwable 클래스를 상속하며, 이 클래스에는 getMessage 메소드가 정의되어 있다.
getMessage 메소드는 예외가 발생한 원인 정보를 문자열의 형태로 반환한다.
예외별로 예외 클래스가 다르다.-> API 문서를 참조해서 찾아야한다.
하나의 try 블록에 둘 이상의 catch 블록을 구성할 수 있다.(오류사항이 catch부분을 순서대로 확인)
항상 실행되는 finally --> try{ }catch{ }finally{ } --> try 부분이 실행되면 무조건 finally 부분 실행.
(중간에 return 문을 실행하더라도 finally 부분을 실행한 뒤 빠져 나간다.)

*18-2 프로그래머가 직접 정의하는 예외의 상황
예외클래스가 되는 방법은 Exception 을 상속 받으면 된다. 대신 예외의 발생도 직접 명시해야한다.
throws 를 사용하면 -> 예외상황이 발생한 지점에서 처리하여라
printStackTrace 메소드를 사용해서->메소드의 호출관계(예외의 전달 흐름)을 볼 수 있다.

*18-3 예외 클래스의 계층도
모든 예외 클래스는 Throwable 메소드를 상속한다.
Error 클래스를 상속하는 예외 클래스는 프로그램 내에서 해결이 불가능한 예외 상황을 알리는 예외 클래스의 정의에 사용된다.
(Error 클래스는 try~catch로 처리가 불가능한 예외이다.)
호출하고자 하는 메소드가 예외를 발생시킬 수 있다면, try~catch문을 통한 예외의 처리라던지, throws를 이용한 예외의 전달을 해야한다.
처리하지 않아도 되는 RuntimeException -> 대부분 프로그램의 종료로 이어지는 것이 자연스러운 경우이기 때문이다.

*19-1 자바 가상머신의 메모리 모델
컴퓨터아키텍처들은 메모리 관리가 중요하다.
가상 메모리 기술을 통해서 모든 응용프로그램에게 동일한 크기의 메모리 공간을 할당 할 수 있다.
JVM은 메모리 공간을 용도에 따라서 별도로 나누어 처리 속도를 빠르게 한다.(메소드,스택,힙 영역)
메소드 영역-> 클래스의 정보가 JVM의 메모리 공간에 LOAD 될때 할당 및 초기화되는 대상은 메소드 영역에 할당된다.
스택 영역-> 임시로 할당되어있다가 바로 소멸되는 특징이 있는 변수가 할당된다.(할당 및 소멸의 특성상 메소드 별 스택이 구분이 된다.)
힙 영역-> JVM에 의한 메모리 공간(Garbage Collection)의 정리가 이뤄지는 공간. 참조변수에 의한 참조가 전혀 이뤄지지 않는 인스턴스가 소멸의 대상이 된다.

*19-2 Object 클래스1
equrls, clone
finalize 메소드-> 인스턴스가 완전히 소멸되기 직전 호출되는 메소드이다.
(Object클래스의 멤버이므로 모든 인스턴스에는 이 메소드가 존재한다.)
GC가 발생하면, 소멸의 대상이 되는 인스턴스는 결정되지만 이것이 실제 소멸로 바로 이어지지는 않는다.
인스턴스의 실제 소멸로 이어지지 않은 상태에서 프로그램이 종료될 수도 있다.(=>종료가 되면 어차피 인스턴스는 소멸되니까)
대상 메소드에 대한 정보가 부족한 경우에는 오버라이딩 된 메소드도 호출이 되도록 오버라이딩 하자(=오버라이딩의 기본)

*19-2 Object 클래스2
clone메소드 -> 인스턴스의 복사를 목적으로 하는 메소드이다.
String 인스턴스에 저장되어 있는 문자열 정보는 변경되지 않는다.
따라서 굳이 String이스턴스를 깊은 복사의 목록에 포함시킬 필요는 없다.

*20-1 Wrapper 클래스
Wrapper 클래스=기본 자료형 data를 감싸는 클래스이다.(=기본 자료형 데이터를 저장 및 참조할 수 있는 구조로 정의)
(Boxing->포장=기본 자료형 데이터를 Wrapper 인스턴스로 감싸는 것)=담고 있는 데이터가 바로 출력된다.
(UnBoxing->포장해제=Wrapper 인스턴스에 저장된 데이터를 꺼내는 것)=담고 있는 데이터가 다른 데이터와 결합하여 출력된다.
Auto Boxing->기본 자료형 데이터가 자동으로 Wrapper 인스턴스로 감싸지는 것
Auto UnBoxing-> Wrapper 인스턴스에 저장된 데이터가 자동으로 꺼내지는 것

*20-2 BigInteger 클래스와 BigDecimal 클래스
BigInteger 자바가 표현하지 못하는 정수를 정의하기 위한 클래스
BigDecimal 오차가 없도록 해야하는 실수를 정의하기 위한 클래스
큰 정수를 문자열로 표현한 이유는 숫자로 표현이 불가능하기 때문이다. 
기본 자료형의 범위를 넘어서는 크기의 정수는 숫자로 표현 불가능하다.

*20-3 Math 클래스와 난수의 생성, 그리고 문자열 토큰의 구분
Math 클래스에는 수학관련 메소드가 static으로 정의되어 있다.
대부분의 메소드가 라디안 단위로 정의되어 있다.(ex 각도)
난수(Random Number)=정해지지 않은 패턴의 숫자
컴퓨터의 난수는 씨앗을 기반으로 생성되기 때문에 가짜 난수라 불린다.
rand.setSeed(System.currentRimeMillis()); ==>현재 시간을 밀리 초 단위로 반환
StringTokenizer(strData,":"); ==> 토큰을 나눌 대상 문자열과 구분자 정보

*21-1 제네릭(Generics) 클래스의 이해와 설계
AppleBox, OrangeBox의 장점인 자료형의 안전성과 FruitBox의 장점인 구현의 편의성을 한데 모은것이 제네릭이다.
"자료형의 안전성"이란 프로그래머의 의도와는 다르게 구동이 되었는데 오류가 발생하지 않는 것을 없애는 것이다.
제네릭<T> => 자료형의 이름(T)은 인스턴스를 생성하는 순간에 결정이 된다.

*21-2 제네릭을 구성하는 다양한 문법적 요소1
제네릭을 공부하는 이유는 컬렉션 프레임워크를 공부하기 위함이다.
컬렉션 프레임워크는=자료구조와 알고리즘을 이용해 프레임워크를 만들어 놓은것이다.
매개변수의 자료형 제한=> public static<T extends AAA> void myMethod(T param){....}
-> T가 AAA를 상속(AAA가 클래스인 경우) 또는 구현(AAA가 인터페이스인 경우)하는 클래스의 자료형이 되어야 함을 명시함.

*21-2 제네릭을 구성하는 다양한 문법적 요소2
<? extends Fruit>가 의미하는 바는 "Fruit을 상속하는 모든 클래스"이다.
->와일드카드는 제한되어있는 범주에 속하는 모든것들.
FruitBox<?> box; ==> 자료형에 상관없이 모든 인스턴스를 참조하겠다.
FruitBox<? super Apple>boundedBox; ==> ~이 상속하는 클래스라면 무엇이든지
<T> 로 구현하면 제네릭클라스가 되는 것이고 <String>으로 구현하면 일반클래스가 된다.
기본자료형의 이름은 제네릭에 사용불가!ex) FruitBox<int>, FruitBox<double>
